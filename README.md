<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"></head><body class="c9"><p class="c6"><span class="c0">Working:</span></p><p class="c6 c10"><span class="c0"><img alt="working-gif" src="working.gif"/></span></p><hr><p class="c6 c10"><span class="c0"></span></p><p class="c6"><span class="c0">Code:</span></p><a id="t.12c18bdb63d4356d909e0cab00a392c79b70a367"></a><a id="t.0"></a><table class="c7"><tbody><tr class="c11"><td class="c13" colspan="1" rowspan="1"><p class="c12"><span class="c3">#include &lt;GL/glut.h&gt; /* including the glut library */</span><span class="c1"><br><br></span><span class="c3">#include &lt;cmath&gt; /* for using sin, cos, sqrt */</span><span class="c1"><br></span><span class="c3">#include &lt;cstdio&gt; /* for using printf and scanf */</span><span class="c1"><br><br></span><span class="c3">#include &quot;imageio.h&quot;</span><span class="c1"><br><br></span><span class="c3">#define WINDOW_WIDTH 1200</span><span class="c1"><br></span><span class="c3">#define WINDOW_HEIGHT 700</span><span class="c1"><br></span><span class="c3">#define ROT_AMT 10.0</span><span class="c1"><br></span><span class="c3">#define LIGHT_INTENSITY_AMT 0.2</span><span class="c1"><br><br></span><span class="c5">int</span><span class="c1">&nbsp;texImageWidth;<br></span><span class="c5">int</span><span class="c1">&nbsp;texImageHeight;<br></span><span class="c5">char</span><span class="c1">&nbsp;texture_file[] = </span><span class="c8">&quot;wall.png&quot;</span><span class="c1">;<br></span><span class="c5">char</span><span class="c1">&nbsp;backface[] = </span><span class="c8">&quot;Back Face&quot;</span><span class="c1">;<br></span><span class="c5">char</span><span class="c1">&nbsp;frontface[] = </span><span class="c8">&quot;Front Face&quot;</span><span class="c1">;<br></span><span class="c5">int</span><span class="c1">&nbsp;initial_x, initial_y, flag;<br><br></span><span class="c5">static</span><span class="c1">&nbsp;GLuint texture_handle[</span><span class="c3">1</span><span class="c1">]; &nbsp;</span><span class="c2">//texture names</span><span class="c1"><br><br></span><span class="c5">float</span><span class="c1">&nbsp;light_intensity = </span><span class="c3">1.0f</span><span class="c1">;<br>GLfloat lightColor[] = {</span><span class="c3">1.0f</span><span class="c1">, </span><span class="c3">1.0f</span><span class="c1">, </span><span class="c3">1.0f</span><span class="c1">, </span><span class="c3">1.0f</span><span class="c1">};<br>GLfloat lightPos[] = {</span><span class="c3">100.0</span><span class="c1">, </span><span class="c3">100.0</span><span class="c1">, </span><span class="c3">100.0</span><span class="c1">, </span><span class="c3">1.0</span><span class="c1">}; </span><span class="c2">/* Infinite light location. */</span><span class="c1"><br><br></span><span class="c2">/* for defining a structure for representing a position vector */</span><span class="c1"><br></span><span class="c5">struct</span><span class="c1">&nbsp;</span><span class="c4">Position</span><span class="c1">&nbsp;{<br> &nbsp; </span><span class="c5">float</span><span class="c1">&nbsp;x, y, z;<br>};<br><br>Position cameraPos = {</span><span class="c3">0.0</span><span class="c1">, </span><span class="c3">0.0</span><span class="c1">, </span><span class="c3">1.0</span><span class="c1">};<br>Position viewUpVector = {</span><span class="c3">0.0</span><span class="c1">, </span><span class="c3">1.0</span><span class="c1">, </span><span class="c3">0.0</span><span class="c1">};<br><br></span><span class="c2">/* this function calculates the square of the given number */</span><span class="c1"><br></span><span class="c5">float</span><span class="c1">&nbsp;</span><span class="c4">sqr</span><span class="c3">(</span><span class="c5">float</span><span class="c3">&nbsp;x)</span><span class="c1">&nbsp;{<br> &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;((x) * (x));<br>}<br><br></span><span class="c2">/* for drawing given text at the given location */</span><span class="c1"><br></span><span class="c5">void</span><span class="c1">&nbsp;</span><span class="c4">renderStrokeFontString</span><span class="c3">(</span><span class="c5">float</span><span class="c3">&nbsp;x, </span><span class="c5">float</span><span class="c3">&nbsp;y, </span><span class="c5">float</span><span class="c3">&nbsp;z, </span><span class="c5">char</span><span class="c3">&nbsp;*string)</span><span class="c1">&nbsp;{<br> &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;*c;<br> &nbsp; glPushMatrix();<br> &nbsp; glTranslatef((</span><span class="c3">10</span><span class="c1">&nbsp;* z) * x, y, z);<br> &nbsp; glScalef((</span><span class="c3">10</span><span class="c1">&nbsp;* z) * </span><span class="c3">0.00025</span><span class="c1">, </span><span class="c3">0.00025</span><span class="c1">, </span><span class="c3">1</span><span class="c1">);<br><br> &nbsp; </span><span class="c5">for</span><span class="c1">&nbsp;(c = </span><span class="c3">string</span><span class="c1">; *c != </span><span class="c8">&#39;\0&#39;</span><span class="c1">; c++) {<br> &nbsp; &nbsp; &nbsp; glutStrokeCharacter(GLUT_STROKE_ROMAN, *c);<br> &nbsp; }<br> &nbsp; glPopMatrix();<br>}<br><br></span><span class="c2">/* load texture image */</span><span class="c1"><br>GLubyte *</span><span class="c4">makeTexImage</span><span class="c3">(</span><span class="c5">char</span><span class="c3">&nbsp;*loadfile)</span><span class="c1">&nbsp;{<br> &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;i, j, c, width, height;<br> &nbsp; GLubyte *texImage;<br> &nbsp; </span><span class="c2">/* Only works for .png or .tif images. &nbsp;NULL is returned if errors occurred.<br> &nbsp; loadImageRGA() is from imageio library downloaded from Internet. */</span><span class="c1"><br> &nbsp; texImage = loadImageRGBA((</span><span class="c5">char</span><span class="c1">&nbsp;*)loadfile, &amp;width, &amp;height);<br> &nbsp; texImageWidth = width;<br> &nbsp; texImageHeight = height;<br> &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;texImage;<br>}<br><br></span><span class="c5">void</span><span class="c1">&nbsp;</span><span class="c4">drawCube</span><span class="c3">()</span><span class="c1">&nbsp;{<br> &nbsp; </span><span class="c5">float</span><span class="c1">&nbsp;x0 = </span><span class="c3">-0.1</span><span class="c1">, y0 = </span><span class="c3">-0.1</span><span class="c1">, x1 = </span><span class="c3">0.1</span><span class="c1">, y1 = </span><span class="c3">0.1</span><span class="c1">, z0 = </span><span class="c3">0.1</span><span class="c1">;<br> &nbsp; </span><span class="c5">float</span><span class="c1">&nbsp;face[</span><span class="c3">6</span><span class="c1">][</span><span class="c3">4</span><span class="c1">][</span><span class="c3">3</span><span class="c1">] = {<br> &nbsp; &nbsp; &nbsp; {{x0, y0, z0}, {x1, y0, z0}, {x1, y1, z0}, {x0, y1, z0}}, &nbsp; &nbsp; </span><span class="c2">/* front */</span><span class="c1"><br> &nbsp; &nbsp; &nbsp; {{x0, y1, -z0}, {x1, y1, -z0}, {x1, y0, -z0}, {x0, y0, -z0}}, </span><span class="c2">/* back */</span><span class="c1"><br> &nbsp; &nbsp; &nbsp; {{x1, y0, z0}, {x1, y0, -z0}, {x1, y1, -z0}, {x1, y1, z0}}, &nbsp; </span><span class="c2">/* right */</span><span class="c1"><br> &nbsp; &nbsp; &nbsp; {{x0, y0, z0}, {x0, y1, z0}, {x0, y1, -z0}, {x0, y0, -z0}}, &nbsp; </span><span class="c2">/* left */</span><span class="c1"><br> &nbsp; &nbsp; &nbsp; {{x0, y1, z0}, {x1, y1, z0}, {x1, y1, -z0}, {x0, y1, -z0}}, &nbsp; </span><span class="c2">/* top */</span><span class="c1"><br> &nbsp; &nbsp; &nbsp; {{x0, y0, z0}, {x0, y0, -z0}, {x1, y0, -z0}, {x1, y0, z0}} &nbsp; &nbsp;</span><span class="c2">/* bottom */</span><span class="c1"><br> &nbsp; };<br> &nbsp; </span><span class="c5">for</span><span class="c1">&nbsp;(</span><span class="c5">int</span><span class="c1">&nbsp;i = </span><span class="c3">0</span><span class="c1">; i &lt; </span><span class="c3">6</span><span class="c1">; ++i) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">/* draw cube with texture images */</span><span class="c1"><br> &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(i == </span><span class="c3">0</span><span class="c1">) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">/* for front face */</span><span class="c1"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glBindTexture(GL_TEXTURE_2D, </span><span class="c3">0</span><span class="c1">); </span><span class="c2">/* do apply texture for this face */</span><span class="c1"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glColor3f(</span><span class="c3">0.0</span><span class="c1">, </span><span class="c3">0.0</span><span class="c1">, </span><span class="c3">0.0</span><span class="c1">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; renderStrokeFontString(</span><span class="c3">-0.09</span><span class="c1">, </span><span class="c3">0.0</span><span class="c1">, </span><span class="c3">0.1</span><span class="c1">, frontface);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glColor3f(</span><span class="c3">0.4</span><span class="c1">, </span><span class="c3">0.5</span><span class="c1">, </span><span class="c3">0.2</span><span class="c1">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glBegin(GL_QUADS);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glVertex3fv(face[i][</span><span class="c3">0</span><span class="c1">]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glVertex3fv(face[i][</span><span class="c3">1</span><span class="c1">]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glVertex3fv(face[i][</span><span class="c3">2</span><span class="c1">]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glVertex3fv(face[i][</span><span class="c3">3</span><span class="c1">]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glEnd();<br> &nbsp; &nbsp; &nbsp; } </span><span class="c5">else</span><span class="c1">&nbsp;</span><span class="c5">if</span><span class="c1">&nbsp;(i == </span><span class="c3">1</span><span class="c1">) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">/* for back face */</span><span class="c1"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glBindTexture(GL_TEXTURE_2D, </span><span class="c3">0</span><span class="c1">); </span><span class="c2">/* do apply texture for this face */</span><span class="c1"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glColor3f(</span><span class="c3">0.4</span><span class="c1">, </span><span class="c3">0.8</span><span class="c1">, </span><span class="c3">0.1</span><span class="c1">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; renderStrokeFontString(</span><span class="c3">-0.09</span><span class="c1">, </span><span class="c3">0.0</span><span class="c1">, </span><span class="c3">-0.1</span><span class="c1">, backface);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glColor3f(</span><span class="c3">1</span><span class="c1">, </span><span class="c3">1</span><span class="c1">, </span><span class="c3">1</span><span class="c1">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glBegin(GL_QUADS);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glVertex3fv(face[i][</span><span class="c3">0</span><span class="c1">]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glVertex3fv(face[i][</span><span class="c3">1</span><span class="c1">]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glVertex3fv(face[i][</span><span class="c3">2</span><span class="c1">]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glVertex3fv(face[i][</span><span class="c3">3</span><span class="c1">]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glEnd();<br> &nbsp; &nbsp; &nbsp; } </span><span class="c5">else</span><span class="c1">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glBindTexture(GL_TEXTURE_2D, texture_handle[</span><span class="c3">0</span><span class="c1">]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glBegin(GL_QUADS);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glTexCoord2f(</span><span class="c3">0.0</span><span class="c1">, </span><span class="c3">0.0</span><span class="c1">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glVertex3fv(face[i][</span><span class="c3">0</span><span class="c1">]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glTexCoord2f(</span><span class="c3">1.0</span><span class="c1">, </span><span class="c3">0.0</span><span class="c1">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glVertex3fv(face[i][</span><span class="c3">1</span><span class="c1">]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glTexCoord2f(</span><span class="c3">1.0</span><span class="c1">, </span><span class="c3">1.0</span><span class="c1">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glVertex3fv(face[i][</span><span class="c3">2</span><span class="c1">]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glTexCoord2f(</span><span class="c3">0.0</span><span class="c1">, </span><span class="c3">1.0</span><span class="c1">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glVertex3fv(face[i][</span><span class="c3">3</span><span class="c1">]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; glEnd();<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; }<br>}<br><br></span><span class="c2">/* Initialize OpenGL Graphics */</span><span class="c1"><br></span><span class="c5">void</span><span class="c1">&nbsp;</span><span class="c4">initGL</span><span class="c3">()</span><span class="c1">&nbsp;{<br> &nbsp; glClearColor(</span><span class="c3">0.0f</span><span class="c1">, </span><span class="c3">0.0f</span><span class="c1">, </span><span class="c3">0.0f</span><span class="c1">, </span><span class="c3">1.0f</span><span class="c1">); </span><span class="c2">/* Set background color to black and opaque */</span><span class="c1"><br> &nbsp; glClearDepth(</span><span class="c3">1.0f</span><span class="c1">); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">/* Set background depth to farthest */</span><span class="c1"><br><br> &nbsp; glGenTextures(</span><span class="c3">1</span><span class="c1">, texture_handle);<br> &nbsp; GLubyte *texImage = makeTexImage(texture_file);<br> &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(!texImage) {<br> &nbsp; &nbsp; &nbsp; </span><span class="c3">fprintf</span><span class="c1">(</span><span class="c3">stderr</span><span class="c1">, </span><span class="c8">&quot;\nError reading %s \n&quot;</span><span class="c1">, texture_file);<br> &nbsp; }<br> &nbsp; glBindTexture(GL_TEXTURE_2D, texture_handle[</span><span class="c3">0</span><span class="c1">]); </span><span class="c2">/* now we work on handles */</span><span class="c1"><br> &nbsp; glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);<br> &nbsp; glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<br> &nbsp; glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br> &nbsp; glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br> &nbsp; glTexImage2D(GL_TEXTURE_2D, </span><span class="c3">0</span><span class="c1">, GL_RGBA, texImageWidth,<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;texImageHeight, </span><span class="c3">0</span><span class="c1">, GL_RGBA, GL_UNSIGNED_BYTE, texImage);<br><br> &nbsp; </span><span class="c5">delete</span><span class="c1">&nbsp;texImage; </span><span class="c2">/* free memory holding texture image */</span><span class="c1"><br><br> &nbsp; </span><span class="c2">/* specifying the viewing frustum into the world coordinate system. */</span><span class="c1"><br> &nbsp; glMatrixMode(GL_PROJECTION);<br> &nbsp; gluPerspective(</span><span class="c2">/* field of view in degree */</span><span class="c1">&nbsp;</span><span class="c3">40.0</span><span class="c1">,<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">/* aspect ratio */</span><span class="c1">&nbsp;</span><span class="c3">1.0</span><span class="c1">,<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">/* Z near */</span><span class="c1">&nbsp;</span><span class="c3">1.0</span><span class="c1">, </span><span class="c2">/* Z far */</span><span class="c1">&nbsp;</span><span class="c3">10.0</span><span class="c1">);<br>}<br><br></span><span class="c2">/* Handler for window-repaint event. Called back when the window first appears and<br> &nbsp;whenever the window needs to be re-painted. */</span><span class="c1"><br></span><span class="c5">void</span><span class="c1">&nbsp;</span><span class="c4">display</span><span class="c3">()</span><span class="c1">&nbsp;{<br> &nbsp; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); &nbsp;</span><span class="c2">// Clear color and depth buffers</span><span class="c1"><br><br> &nbsp; </span><span class="c2">/* Enabling required features of OpenGL */</span><span class="c1"><br> &nbsp; glEnable(GL_LIGHTING);<br> &nbsp; glEnable(GL_LIGHT0);<br> &nbsp; glEnable(GL_TEXTURE_2D);<br> &nbsp; glEnable(GL_DEPTH_TEST);<br> &nbsp; glEnable(GL_CULL_FACE);<br> &nbsp; glEnable(GL_BLEND);<br> &nbsp; glEnable(GL_LINE_SMOOTH);<br> &nbsp; glEnable(GL_COLOR_MATERIAL);<br><br> &nbsp; glLineWidth(</span><span class="c3">2.0</span><span class="c1">); </span><span class="c2">/* setting line width for glutStrokeCharacter */</span><span class="c1"><br><br> &nbsp; glShadeModel(GL_FLAT); </span><span class="c2">/* setting shading model to flat */</span><span class="c1"><br><br> &nbsp; glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);<br><br> &nbsp; glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);<br><br> &nbsp; glCullFace(GL_BACK); </span><span class="c2">/* back-facing polygons are culled */</span><span class="c1"><br><br> &nbsp; GLfloat ambientLight[] = {light_intensity, light_intensity, light_intensity, </span><span class="c3">1.0f</span><span class="c1">};<br> &nbsp; glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ambientLight);<br> &nbsp; glLightfv(GL_LIGHT0, GL_DIFFUSE, lightColor); &nbsp;</span><span class="c2">/* Diffuse (non-shiny) light component */</span><span class="c1"><br> &nbsp; glLightfv(GL_LIGHT0, GL_SPECULAR, lightColor); </span><span class="c2">/* Specular (shiny) light component */</span><span class="c1"><br><br> &nbsp; glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);<br><br> &nbsp; glMatrixMode(GL_MODELVIEW); </span><span class="c2">/* To operate on model-view matrix */</span><span class="c1"><br> &nbsp; glLoadIdentity(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">/* Reset the model-view matrix */</span><span class="c1"><br><br> &nbsp; </span><span class="c2">/* set camera position (PRP) and viewing point (VRP) */</span><span class="c1"><br> &nbsp; gluLookAt(cameraPos.x, cameraPos.y, cameraPos.z, </span><span class="c3">0</span><span class="c1">, </span><span class="c3">0</span><span class="c1">, </span><span class="c3">0</span><span class="c1">, viewUpVector.x, viewUpVector.y, viewUpVector.z);<br><br> &nbsp; drawCube(); </span><span class="c2">/* draw our cube */</span><span class="c1"><br><br> &nbsp; glutSwapBuffers(); </span><span class="c2">/* Swap the front and back frame buffers (double buffering) */</span><span class="c1"><br> &nbsp; glDisable(GL_TEXTURE_2D);<br>}<br><br></span><span class="c2">/* this function maps keyboard keys to actions */</span><span class="c1"><br>GLvoid </span><span class="c4">windowKey</span><span class="c3">(</span><span class="c5">unsigned</span><span class="c3">&nbsp;</span><span class="c5">char</span><span class="c3">&nbsp;key, </span><span class="c5">int</span><span class="c3">&nbsp;x, </span><span class="c5">int</span><span class="c3">&nbsp;y)</span><span class="c1">&nbsp;{<br> &nbsp; </span><span class="c5">switch</span><span class="c1">&nbsp;(key) {<br> &nbsp; &nbsp; &nbsp; </span><span class="c5">case</span><span class="c1">&nbsp;</span><span class="c3">27</span><span class="c1">: </span><span class="c2">/* 27 is for esc key, press escape to exit */</span><span class="c1"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">exit</span><span class="c1">(</span><span class="c3">0</span><span class="c1">);<br> &nbsp; &nbsp; &nbsp; </span><span class="c5">case</span><span class="c1">&nbsp;</span><span class="c8">&#39;t&#39;</span><span class="c1">: </span><span class="c2">/* t is for reset */</span><span class="c1"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; light_intensity = </span><span class="c3">1.0</span><span class="c1">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cameraPos.x = </span><span class="c3">0.0</span><span class="c1">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cameraPos.y = </span><span class="c3">0.0</span><span class="c1">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cameraPos.z = </span><span class="c3">1.0</span><span class="c1">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; viewUpVector.x = </span><span class="c3">0.0</span><span class="c1">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; viewUpVector.y = </span><span class="c3">1.0</span><span class="c1">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; viewUpVector.z = </span><span class="c3">0.0</span><span class="c1">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;<br> &nbsp; &nbsp; &nbsp; </span><span class="c5">case</span><span class="c1">&nbsp;</span><span class="c8">&#39;+&#39;</span><span class="c1">: </span><span class="c2">/* increase the light intensity */</span><span class="c1"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(light_intensity &lt; </span><span class="c3">1.0</span><span class="c1">)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; light_intensity += LIGHT_INTENSITY_AMT;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;<br> &nbsp; &nbsp; &nbsp; </span><span class="c5">case</span><span class="c1">&nbsp;</span><span class="c8">&#39;-&#39;</span><span class="c1">: </span><span class="c2">/* decrease the light intensity */</span><span class="c1"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(light_intensity &gt; </span><span class="c3">0.4</span><span class="c1">)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; light_intensity -= LIGHT_INTENSITY_AMT;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;<br> &nbsp; &nbsp; &nbsp; </span><span class="c5">default</span><span class="c1">:<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">printf</span><span class="c1">(</span><span class="c8">&quot;Key %d has no action assigned.\n&quot;</span><span class="c1">, key);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;<br> &nbsp; };<br> &nbsp; glutPostRedisplay(); </span><span class="c2">/* repaint the window after perfoming the updation */</span><span class="c1"><br>}<br><br></span><span class="c2">/* this function is used to normalize the given point/vector */</span><span class="c1"><br>Position </span><span class="c4">normalize</span><span class="c3">(Position point)</span><span class="c1">&nbsp;{<br> &nbsp; Position normalized_point;<br> &nbsp; </span><span class="c5">float</span><span class="c1">&nbsp;x = point.x, y = point.y, z = point.z;<br> &nbsp; </span><span class="c5">float</span><span class="c1">&nbsp;norm = </span><span class="c3">sqrt</span><span class="c1">(sqr(x) + sqr(y) + sqr(z));<br> &nbsp; normalized_point.x = x / norm;<br> &nbsp; normalized_point.y = y / norm;<br> &nbsp; normalized_point.z = z / norm;<br> &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;normalized_point;<br>}<br><br></span><span class="c2">/* this function returns the crossproduct of viewUpVector and CameraPosition and thus returns the viewRightVector */</span><span class="c1"><br>Position </span><span class="c4">crossProduct</span><span class="c3">()</span><span class="c1">&nbsp;{<br> &nbsp; </span><span class="c5">float</span><span class="c1">&nbsp;a, b, c, d, e, f;<br> &nbsp; a = viewUpVector.x;<br> &nbsp; b = viewUpVector.y;<br> &nbsp; c = viewUpVector.z;<br> &nbsp; d = cameraPos.x;<br> &nbsp; e = cameraPos.y;<br> &nbsp; f = cameraPos.z;<br> &nbsp; Position viewRightVector = {b * f - e * c, d * c - a * f, a * e - b * d};<br> &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;normalize(viewRightVector);<br>}<br><br></span><span class="c2">/* this function rotates the given point about the given axis by the given angle */</span><span class="c1"><br>Position </span><span class="c4">rotateAboutAxis</span><span class="c3">(Position point, </span><span class="c5">float</span><span class="c3">&nbsp;angle, Position axis)</span><span class="c1">&nbsp;{<br> &nbsp; </span><span class="c5">float</span><span class="c1">&nbsp;c = </span><span class="c3">cos</span><span class="c1">(angle), s = </span><span class="c3">sin</span><span class="c1">(angle), x = axis.x, y = axis.y, z = axis.z;<br> &nbsp; </span><span class="c5">float</span><span class="c1">&nbsp;Mr[</span><span class="c3">4</span><span class="c1">][</span><span class="c3">4</span><span class="c1">] = {<br> &nbsp; &nbsp; &nbsp; {(</span><span class="c3">1</span><span class="c1">&nbsp;- c) * sqr(x) + c, (</span><span class="c3">1</span><span class="c1">&nbsp;- c) * x * y - s * z, (</span><span class="c3">1</span><span class="c1">&nbsp;- c) * x * z + s * y, </span><span class="c3">0</span><span class="c1">},<br> &nbsp; &nbsp; &nbsp; {(</span><span class="c3">1</span><span class="c1">&nbsp;- c) * x * y + s * z, (</span><span class="c3">1</span><span class="c1">&nbsp;- c) * sqr(y) + c, (</span><span class="c3">1</span><span class="c1">&nbsp;- c) * y * z - s * x, </span><span class="c3">0</span><span class="c1">},<br> &nbsp; &nbsp; &nbsp; {(</span><span class="c3">1</span><span class="c1">&nbsp;- c) * x * z - s * y, (</span><span class="c3">1</span><span class="c1">&nbsp;- c) * y * z + s * x, (</span><span class="c3">1</span><span class="c1">&nbsp;- c) * sqr(x) + c, </span><span class="c3">0</span><span class="c1">},<br> &nbsp; &nbsp; &nbsp; {</span><span class="c3">0</span><span class="c1">, </span><span class="c3">0</span><span class="c1">, </span><span class="c3">0</span><span class="c1">, </span><span class="c3">1</span><span class="c1">}};<br> &nbsp; Position new_point;<br> &nbsp; new_point.x = Mr[</span><span class="c3">0</span><span class="c1">][</span><span class="c3">0</span><span class="c1">] * point.x + Mr[</span><span class="c3">0</span><span class="c1">][</span><span class="c3">1</span><span class="c1">] * point.y + Mr[</span><span class="c3">0</span><span class="c1">][</span><span class="c3">2</span><span class="c1">] * point.z;<br> &nbsp; new_point.y = Mr[</span><span class="c3">1</span><span class="c1">][</span><span class="c3">0</span><span class="c1">] * point.x + Mr[</span><span class="c3">1</span><span class="c1">][</span><span class="c3">1</span><span class="c1">] * point.y + Mr[</span><span class="c3">1</span><span class="c1">][</span><span class="c3">2</span><span class="c1">] * point.z;<br> &nbsp; new_point.z = Mr[</span><span class="c3">2</span><span class="c1">][</span><span class="c3">0</span><span class="c1">] * point.x + Mr[</span><span class="c3">2</span><span class="c1">][</span><span class="c3">1</span><span class="c1">] * point.y + Mr[</span><span class="c3">2</span><span class="c1">][</span><span class="c3">2</span><span class="c1">] * point.z;<br> &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;normalize(new_point);<br>}<br><br>GLvoid </span><span class="c4">onMouseMotion</span><span class="c3">(</span><span class="c5">int</span><span class="c3">&nbsp;x, </span><span class="c5">int</span><span class="c3">&nbsp;y)</span><span class="c1">&nbsp;{<br> &nbsp; </span><span class="c2">/* &nbsp;Calculate the amount of rotation given the mouse movement. */</span><span class="c1"><br> &nbsp; </span><span class="c5">float</span><span class="c1">&nbsp;deltaAngleX = (</span><span class="c3">2</span><span class="c1">&nbsp;* M_PI / glutGet(GLUT_WINDOW_WIDTH)); </span><span class="c2">/* a movement from left to right = 2*PI = 360 deg */</span><span class="c1"><br> &nbsp; </span><span class="c5">float</span><span class="c1">&nbsp;deltaAngleY = (M_PI / glutGet(GLUT_WINDOW_HEIGHT)); &nbsp; &nbsp;</span><span class="c2">/* a movement from top to bottom = PI = 180 deg */</span><span class="c1"><br> &nbsp; </span><span class="c5">float</span><span class="c1">&nbsp;xAngle = (initial_x - x) * deltaAngleX;<br> &nbsp; </span><span class="c5">float</span><span class="c1">&nbsp;yAngle = (initial_y - y) * deltaAngleY;<br><br> &nbsp; Position viewRightVector = crossProduct();<br> &nbsp; </span><span class="c2">/* &nbsp;Rotate the camera around the pivot point on the first axis */</span><span class="c1"><br> &nbsp; Position new_point = rotateAboutAxis(cameraPos, yAngle, viewRightVector);<br><br> &nbsp; </span><span class="c2">/* &nbsp;Rotate the camera around the pivot point on the second axis */</span><span class="c1"><br> &nbsp; cameraPos = rotateAboutAxis(new_point, xAngle, viewUpVector);<br><br> &nbsp; viewUpVector = rotateAboutAxis(viewUpVector, yAngle, viewRightVector);<br><br> &nbsp; initial_x = x;<br> &nbsp; initial_y = y;<br> &nbsp; glutPostRedisplay();<br>}<br><br></span><span class="c2">/* function which gets activated whenever user presses a mouse button. It sets the initial x and y for use by onMouseMotion()*/</span><span class="c1"><br>GLvoid </span><span class="c4">mouseButtonPressed</span><span class="c3">(GLint pressedButton, GLint cur_state, GLint x, GLint y)</span><span class="c1">&nbsp;{<br> &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(pressedButton != GLUT_LEFT_BUTTON)<br> &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">;<br><br> &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(cur_state == GLUT_UP) {<br> &nbsp; &nbsp; &nbsp; flag = </span><span class="c3">0</span><span class="c1">;<br> &nbsp; } </span><span class="c5">else</span><span class="c1">&nbsp;{<br> &nbsp; &nbsp; &nbsp; flag = </span><span class="c3">1</span><span class="c1">;<br> &nbsp; &nbsp; &nbsp; initial_x = x;<br> &nbsp; &nbsp; &nbsp; initial_y = y;<br> &nbsp; }<br>}<br><br></span><span class="c2">/* Handler for window re-size event. Called back when the window first appears and<br> &nbsp;whenever the window is re-sized with its new width and height */</span><span class="c1"><br></span><span class="c5">void</span><span class="c1">&nbsp;</span><span class="c4">reshape</span><span class="c3">(GLsizei width, GLsizei height)</span><span class="c1">&nbsp;{ &nbsp;</span><span class="c2">// GLsizei for non-negative integer</span><span class="c1"><br> &nbsp; </span><span class="c2">/* Compute aspect ratio of the new window */</span><span class="c1"><br> &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(height == </span><span class="c3">0</span><span class="c1">) height = </span><span class="c3">1</span><span class="c1">; </span><span class="c2">/* To prevent divide by 0 */</span><span class="c1"><br> &nbsp; GLfloat aspect = (GLfloat)width / (GLfloat)height;<br> &nbsp; glViewport(</span><span class="c3">0</span><span class="c1">, </span><span class="c3">0</span><span class="c1">, width, height); </span><span class="c2">/* Set the viewport to cover the new window */</span><span class="c1"><br><br> &nbsp; </span><span class="c2">/* Set the aspect ratio of the clipping volume to match the viewport */</span><span class="c1"><br> &nbsp; glMatrixMode(GL_PROJECTION); </span><span class="c2">/* To operate on the Projection matrix */</span><span class="c1"><br> &nbsp; glLoadIdentity(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">/* Reset */</span><span class="c1"><br> &nbsp; </span><span class="c2">/* Enable perspective projection with fovy, aspect, zNear and zFar */</span><span class="c1"><br> &nbsp; gluPerspective(</span><span class="c3">45.0f</span><span class="c1">, aspect, </span><span class="c3">0.1f</span><span class="c1">, </span><span class="c3">100.0f</span><span class="c1">);<br>}<br><br></span><span class="c2">/* Main function: GLUT runs as a console application starting at main() */</span><span class="c1"><br></span><span class="c5">int</span><span class="c1">&nbsp;</span><span class="c4">main</span><span class="c3">(</span><span class="c5">int</span><span class="c3">&nbsp;argc, </span><span class="c5">char</span><span class="c3">&nbsp;**argv)</span><span class="c1">&nbsp;{<br> &nbsp; glutInit(&amp;argc, argv); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">// Initialize GLUT</span><span class="c1"><br> &nbsp; glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH); &nbsp;</span><span class="c2">// Enable double buffered mode</span><span class="c1"><br> &nbsp; glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">// Set the window&#39;s initial width &amp; height</span><span class="c1"><br> &nbsp; glutInitWindowPosition(</span><span class="c3">0</span><span class="c1">, </span><span class="c3">0</span><span class="c1">); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">// Position the window&#39;s initial top-left corner</span><span class="c1"><br> &nbsp; glutCreateWindow(</span><span class="c8">&quot;Cube&quot;</span><span class="c1">); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">// Create window with the given title</span><span class="c1"><br> &nbsp; glutDisplayFunc(display); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">// Register callback handler for window re-paint event</span><span class="c1"><br> &nbsp; glutReshapeFunc(reshape); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">// Register callback handler for window re-size event</span><span class="c1"><br> &nbsp; initGL(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">// Our own OpenGL initialization</span><span class="c1"><br> &nbsp; glutKeyboardFunc(&amp;windowKey); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">// Our key pressed handler function</span><span class="c1"><br> &nbsp; glutMouseFunc(&amp;mouseButtonPressed); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">// Registering mouse button handler function</span><span class="c1"><br> &nbsp; glutMotionFunc(&amp;onMouseMotion); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">// Registering mouse motion handler function</span><span class="c1"><br> &nbsp; glutMainLoop(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">// Enter the infinite event-processing loop</span><span class="c1"><br> &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;</span><span class="c3">0</span><span class="c1">;<br>}</span></p></td></tr></tbody></table><p class="c6 c10"><span class="c0"></span></p><p class="c6"><span>Output:</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image7.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image10.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image4.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image6.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image3.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image2.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image8.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image9.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></body></html>